Java e JSF I


JSF - Java Server Faces é a documentação, Mojarra é uma das implementações.

@ManagedBean - Indica que a classe será gerenciada pelo JSF. Objetos dessa classe serão administrados pelo JSF. 
Ou seja, o JSF vai decidir quando criar um objeto da classe LivroBean.

Expression Language - #{} - É o que liga(binding) a class com o xhtml, por exemplo:

action=" #{livroBean.gravar} "

É utilizado um Servlet Container - Tomcat que é diferente de um Servidor de Aplicação/EJB Container

Estamos usando o Dynamic Web Project com os modules na versão 3.0

As libs externas são colocadas dentro da pasta WebContent > WEB-INF > lib.

web.xml - relacionado com a especificação servlet.

faces-config.xml - relacionado as configurações de JSF, como a utilização de anotações é utilizada da versão 2
ele é pouco utilizado.

É necessária uma mudança no mapeamento dentro do web.xml

De:

	<servlet-mapping>
    	<servlet-name>Faces Servlet</servlet-name>
    	<url-pattern>/faces/*</url-pattern>
  	</servlet-mapping>

Para:

	<servlet-mapping>
    	<servlet-name>Faces Servlet</servlet-name>
    	<url-pattern>*.xhtml</url-pattern>
  	</servlet-mapping>
  	
  	
  	
É usado o padrão XHTML para desenvolver as páginas e "injetar" o jsf com os namespaces(importações) por exemplo:

	xmlns:h="http://java.sun.com/jsf/html" - Importação que serve para declarar componentes JSF
	

Observação: Interessante o uso da tag fieldset + legend, tem um efeito legal na página.

ManagedBean != SessionBean - ManagedBean é para JSF, SessionBean é para EJB Container.

Por padrão qualquer JAR da aplicação web deve estar dentro da pasta WEB-INF/lib.

O servlet JSF tem o papel do controlador.



Modelo arquitetural MVC: Model-View-Controller

eguimos um modelo arquitetural de separação em três camadas na qual cada camada possui uma responsabilidade bem definida. 
A primeira camada é a do controlador, que recebe a requisição e decide qual página chamar (Faces Servlet). A segunda é a da visão 
(a definição da interface gráfica, XHTML). E por último, temos o nosso modelo (que representa o domínio da aplicação). 
O ManagedBean é um intermediário e sua responsabilidade pode variar. Este modelo arquitetural é chamado Model-View-Controller ou MVC.

Tem uma imagem na pasta info que ajuda na explicação, MVC - Java Server Faces.png



O ciclo de vida básico dos componentes JSF

Links referência:

https://www.devmedia.com.br/ciclo-de-vida-do-javaserver-faces-jsf/27893
https://imasters.com.br/back-end/conheca-o-ciclo-fe-vida-do-jsf
https://medium.com/@rafaelvicio/entendendo-o-ciclo-de-vida-do-jsf-c003a76924da



JSF – Lidando com o estado da view

http://blog.caelum.com.br/jsf-lidando-com-o-estado-da-view/



Erro de Utilização de Dados da Tela 

Nesse situação a tela possuí um combo box com os Autores e tem o método que associa com o Livro.
E outro método que envia para o banco "todos" esses dados porem, mesmo depois de ter associado o erro persiste pois, 
os dados são perdidos nas requisições, cada método faz uma requisição ao servidor e como está configurado 
como escopo de requisição por padrão @RequestScoped, os dados são perdidos ocasionando o erro, é necessário
modificar para que os dados durem enquanto a tela durar, seria o escopo de tela @ViewScoped.



A utilização dos componente é fácil, necessário saber o funcionamento, que pode ser aprendido com Showcases do PrimeFaces por exemplo.



Utilização de outras taglibs para criação de componentes na tela





Escopos no JSF - Request, Session, Application, View

Links:

	https://www.portaleducacao.com.br/conteudo/artigos/informatica/entendendo-os-escopos-no-jsf-(javaserver-faces)/56539

	https://www.devmedia.com.br/escopos-de-managed-beans-no-jsf-2-0/20436

	http://eumaismais.com.br/2016/03/31/jsf-entendendo-e-utilizando-corretamente-os-escopos/





O que é FacesContext, Validadores, Conversores, Mensagens de Erro.

Validador :

public void comecarComDigitoUm(FacesContext fc, UIComponent component, Object value) throws ValidatorException {}

Assinatura padrão de um método que será validador:

	FacesContext a view que está sendo processada no momento
	UIComponent, componente da view que será validado.
	Object valor que será avaliado.
	
	Necessário lançar uma exceção do tipo ValidatorException para que seja lançada pelo h:message, h:messages ou algo do tipo
	
	O primeiro parâmetro é do tipo javax.faces.context.FacesContext e permite obter informações da view processada no momento.

	O segundo parâmetro é do tipo javax.faces.component.UIComponent e é um referencia ao componente que está sendo validado, normalmente um UIInput.

	O terceiro parâmetro é do tipo java.lang.Object e é um objeto que representa o valor digitado pelo usuário. O objeto já foi convertido.



Exemplo de conversor de data:

				<h:outputLabel value="Data de Lançamento:" for="dataLancamento" />
				<h:inputText id="dataLancamento"
					value="#{livroBean.livro.dataLancamento.time}">
					<!-- O tipo da data é Calendar mas o conversor só sabe lidar com Date -->
					<f:convertDateTime pattern="dd/MM/yyyy"
						timeZone="America/Sao_Paulo" />
					<!-- Máscara de data que será aceita pelo jsf -->
				</h:inputText>
				
				

Mensagens de Erro são passadas por:

Bean Gerenciavel (ManagedBean)

FacesContext.getInstance().addMessage("id_página - que é o proprio nome", new FacesMessage("Messagem que se queria passar");

Exibido na JSF por:

<h:messages> - Para todas as mensagens.

<h:message for="id_componente"> - Para um componente específico.








JSF com AJAX 

