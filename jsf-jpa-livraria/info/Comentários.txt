Java e JSF I


JSF - Java Server Faces é a documentação, Mojarra é uma das implementações.

@ManagedBean - Indica que a classe será gerenciada pelo JSF. Objetos dessa classe serão administrados pelo JSF. 
Ou seja, o JSF vai decidir quando criar um objeto da classe LivroBean.

Expression Language - #{} - É o que liga(binding) a class com o xhtml, por exemplo:

action=" #{livroBean.gravar} "

É utilizado um Servlet Container - Tomcat que é diferente de um Servidor de Aplicação/EJB Container

Estamos usando o Dynamic Web Project com os modules na versão 3.0

As libs externas são colocadas dentro da pasta WebContent > WEB-INF > lib.

web.xml - relacionado com a especificação servlet.

faces-config.xml - relacionado as configurações de JSF, como a utilização de anotações é utilizada da versão 2
ele é pouco utilizado.

É necessária uma mudança no mapeamento dentro do web.xml

De:

	<servlet-mapping>
    	<servlet-name>Faces Servlet</servlet-name>
    	<url-pattern>/faces/*</url-pattern>
  	</servlet-mapping>

Para:

	<servlet-mapping>
    	<servlet-name>Faces Servlet</servlet-name>
    	<url-pattern>*.xhtml</url-pattern>
  	</servlet-mapping>
  	
  	
  	
É usado o padrão XHTML para desenvolver as páginas e "injetar" o jsf com os namespaces(importações) por exemplo:

	xmlns:h="http://java.sun.com/jsf/html" - Importação que serve para declarar componentes JSF
	

Observação: Interessante o uso da tag fieldset + legend, tem um efeito legal na página.

ManagedBean != SessionBean - ManagedBean é para JSF, SessionBean é para EJB Container.

Por padrão qualquer JAR da aplicação web deve estar dentro da pasta WEB-INF/lib.

O servlet JSF tem o papel do controlador.



Modelo arquitetural MVC: Model-View-Controller

eguimos um modelo arquitetural de separação em três camadas na qual cada camada possui uma responsabilidade bem definida. 
A primeira camada é a do controlador, que recebe a requisição e decide qual página chamar (Faces Servlet). A segunda é a da visão 
(a definição da interface gráfica, XHTML). E por último, temos o nosso modelo (que representa o domínio da aplicação). 
O ManagedBean é um intermediário e sua responsabilidade pode variar. Este modelo arquitetural é chamado Model-View-Controller ou MVC.

Tem uma imagem na pasta info que ajuda na explicação, MVC - Java Server Faces.png



O ciclo de vida básico dos componentes JSF

Links referência:

https://www.devmedia.com.br/ciclo-de-vida-do-javaserver-faces-jsf/27893
https://imasters.com.br/back-end/conheca-o-ciclo-fe-vida-do-jsf
https://medium.com/@rafaelvicio/entendendo-o-ciclo-de-vida-do-jsf-c003a76924da



JSF – Lidando com o estado da view

http://blog.caelum.com.br/jsf-lidando-com-o-estado-da-view/



Erro de Utilização de Dados da Tela 

Nesse situação a tela possuí um combo box com os Autores e tem o método que associa com o Livro.
E outro método que envia para o banco "todos" esses dados porem, mesmo depois de ter associado o erro persiste pois, 
os dados são perdidos nas requisições, cada método faz uma requisição ao servidor e como está configurado 
como escopo de requisição por padrão @RequestScoped, os dados são perdidos ocasionando o erro, é necessário
modificar para que os dados durem enquanto a tela durar, seria o escopo de tela @ViewScoped.



A utilização dos componente é fácil, necessário saber o funcionamento, que pode ser aprendido com Showcases do PrimeFaces por exemplo.



Utilização de outras taglibs para criação de componentes na tela





Escopos no JSF - Request, Session, Application, View

Links:

	https://www.portaleducacao.com.br/conteudo/artigos/informatica/entendendo-os-escopos-no-jsf-(javaserver-faces)/56539

	https://www.devmedia.com.br/escopos-de-managed-beans-no-jsf-2-0/20436

	http://eumaismais.com.br/2016/03/31/jsf-entendendo-e-utilizando-corretamente-os-escopos/





O que é FacesContext, Validadores, Conversores, Mensagens de Erro.

Validador :

public void comecarComDigitoUm(FacesContext fc, UIComponent component, Object value) throws ValidatorException {}

Assinatura padrão de um método que será validador:

	FacesContext a view que está sendo processada no momento
	UIComponent, componente da view que será validado.
	Object valor que será avaliado.
	
	Necessário lançar uma exceção do tipo ValidatorException para que seja lançada pelo h:message, h:messages ou algo do tipo
	
	O primeiro parâmetro é do tipo javax.faces.context.FacesContext e permite obter informações da view processada no momento.

	O segundo parâmetro é do tipo javax.faces.component.UIComponent e é um referencia ao componente que está sendo validado, normalmente um UIInput.

	O terceiro parâmetro é do tipo java.lang.Object e é um objeto que representa o valor digitado pelo usuário. O objeto já foi convertido.



Exemplo de conversor de data:

				<h:outputLabel value="Data de Lançamento:" for="dataLancamento" />
				<h:inputText id="dataLancamento"
					value="#{livroBean.livro.dataLancamento.time}">
					<!-- O tipo da data é Calendar mas o conversor só sabe lidar com Date -->
					<f:convertDateTime pattern="dd/MM/yyyy"
						timeZone="America/Sao_Paulo" />
					<!-- Máscara de data que será aceita pelo jsf -->
				</h:inputText>
				
				

Mensagens de Erro são passadas por:

Bean Gerenciavel (ManagedBean)

FacesContext.getInstance().addMessage("id_página - que é o proprio nome", new FacesMessage("Messagem que se queria passar");

Exibido na JSF por:

<h:messages> - Para todas as mensagens.

<h:message for="id_componente"> - Para um componente específico.








JSF com AJAX 

links: {
	https://www.devmedia.com.br/utilizando-ajax-com-java-server-faces-jsf/24832
	http://www.rponte.com.br/2008/04/10/utilizando-ajax-com-jsf-de-maneira-eficiente/
	http://jamacedo.com/2010/04/aprenda-a-utilizar-o-ajax-nativo-do-jsf-2-0/
	https://www.tutorialspoint.com/jsf/jsf_ajax.htm
}

Não enviar todas as informações também pode ser vantajoso porque o processamento dos dados no lado do servidor pode ser demorado. 
Nesse caso o navegador espera sincronamente até a resposta chegar. Ele fica aguardando a resposta para atualizar a tela inteira e 
causa a famosa tela branca. Isso cria uma experiência ruim para o usuário final.

Então vamos mandar uma requisição por trás da interface, que não necessita de uma atualização completa da tela, e envia apenas 
uma parte do formulário. O usuário nem deve sentir que houve essa requisição. Assim que a resposta chegar, atualizamos apenas 
a parte da tela em questão. Essa forma de enviar as requisições se chama AJAX.

Aliando JSF 2 e AJAX

AJAX melhora a usabilidade da interface e, graças aos componentes JSF, pode ser feito de uma forma muito simples. 
Não é preciso saber detalhes sobre JavaScript e a atualização programática da tela. Tudo isso é feito de forma 
transparente para o desenvolvedor, bastando apenas ativar o AJAX no lugar desejado. Para tal existe um componente: 

f:ajax

Vamos associar f:ajax com o h:commandButton. O botão sabe então que vai enviar uma requisição AJAX que NÃO submete 
o formulário inteiro. Falta então definir o que queremos enviar nessa requisição. Claro, apenas o valor do h:combobox. 
Para isso existe o atributo execute, nele definimos os IDs dos componentes que queremos enviar na requisição.

<h:commandButton value="Gravar Autor" action="#{livroBean.gravarAutor}" >
    <f:ajax execute="autor" />
</h:commandButton>

Vamos adicionar no componente h:selectOneMenu o ID. O mesmo ID é utilizado no atributo execute do f:ajax. Assim o comando sabe que queremos enviar o valor do componentes na requisição.

<h:selectOneMenu value="#{livroBean.autorId}" id="autor">
    <!-- codigo omitido -->
</h:selectOneMenu>

Por último falta adicionar no início da página o componente h:head. Como AJAX é baseado no JavaScript, 
que roda no navegador, o JSF precisa associar no cabeçalho uma biblioteca JavaScript. 
Para tal precisa ter o h:head.

<html xmlns="http://www.w3.org/1999/xhtml"
        xmlns:h="http://java.sun.com/jsf/html"
        xmlns:f="http://java.sun.com/jsf/core">

    <h:head />

    <h:body>
            <!-- codigo omitido -->
    </h:body>
</html>

Ao recarregar a página podemos visualizar o código fonte dela (no navegador Chrome e Firefox, pressione ctrl + u).
 O código gerado está um pouco mal formatado, mas podemos procurar o elemento head e lá dentro podemos ver a 
 arquivo JavaScript adicionado automaticamente pelo JSF. É este arquivo que possui as funções AJAX, 
 mas ainda bem que não precisamos nos preocupar com esses detalhes.

Vamos fechar essa janela e testar o formulário. Ao apertar o botão Gravar Autor parece que nada acontece na aplicação. 
Ao verificar o console do Eclipse podemos ver que o método gravarAutor() foi chamado, ou seja, o JSF fez a requisição 
AJAX e enviou o ID do Autor selecionado para o servidor.

Renderizando componentes do JSF com AJAX

Faltou ainda definir qual parte da página queremos atualizar. Quando selecionarmos o Autor seu nome deve aparecer 
na tabela abaixo do h:combobox. Aqui também é preciso configurar o componente f:ajax. O atributo render recebe os 
IDs dos componentes que queremos atualizar, no nosso caso o ID da tabela de autores. Como a tabela não possui 
ainda um ID, colocaremos um agora repetindo-o no atributo render. Pronto!

<h:commandButton value="Gravar Autor" action="#{livroBean.gravarAutor}" >
    <f:ajax execute="autor" render="tabelaAutores"/>
</h:commandButton>

Ao voltar no navegador e testar novamente o botão gravar, o Autor é enviado e a requisição AJAX atualiza a tabela. 
Repare que os dados do livro não foram enviados, não houve validação do titulo. Houve uma atualização parcial da página.

AJAX nos componentes de entrada

Ótimo, usamos AJAX com um h:commandButton, mas f:ajax não se limita aos comandos e também pode ser aplicado nos componentes 
de input. Vamos mostrar isso no h:inputText do titular. O f:ajax dentro de um input significa que os dados serão enviados 
via AJAX. Aqui há algumas opções para definir o momento exato da requisição. Podemos declarar que cada vez que soltamos 
uma tecla deve ser enviado uma requisição, ou quando o input recebe (ou perde) o focus. No exemplo submetemos os dados 
quando o campo perde o focus, indicado pelo atributo event com o valor blur.

Igual a parte anterior, também podemos especificar o que queremos atualizar após a requisição. A vantagem de usar AJAX 
no input é que a validação é executada na hora, quando o usuário digita no campo. Novamente irá melhorar a usabilidade, 
mas isso só funciona se atualizarmos as mensagens para apresentar possíveis problemas de validação. Aqui também é 
preciso fazer a associação com o ID do componente.

<h:inputText id="titulo" value="#{livroBean.livro.titulo}" required="true" 
    requiredMessage="Título obrigatório" validatorMessage="Título não pode ser superior a 40">
            <f:validateLength maximum="40" />
            <f:ajax event="blur" render="messages"/>
</h:inputText>

No navegador vamos atualizar página e testar o titular. Vamos deixar o campo em branco. Repare que, ao perder o focus, aparece na mesma hora o erro de validação.

Enviando o formulário inteiro

Por último vamos usar AJAX também no botão que grava o livro. Enviaremos todas as informações do livro com AJAX. Aqui não há novidade, 
temos a tag f:ajax dentro do botão. Também precisamos declarar os IDs dos componentes que queremos incluir na requisição. 
No atributo render podemos usar uma lista de IDs, porém muitos IDs ficam trabalhosos, facilitando erros. Por este motivo existe um atalho, 
o @form, para indicar o envio do formulário inteiro. Além do @form há outras possibilidades, como por exemplo @all. Ele indica 
que queremos enviar a página inteira.
Além disso, é preciso definir o que queremos atualizar. Nesse exemplo é preciso atualizar o formulário, indicado pelo @form e a tabela 
para o mostrar o novo livro. A tabela será referenciada novamente pelo ID, como já fizemos, porém repare que elas não estão no mesmo formulário. 
Colocando o ID apenas, significa que o f:ajax procurará o componente no mesmo formulário. Para encontrar o componente fora do form é 
preciso usar o caminho absoluto indicado pelo ":" na frente do ID.

<h:commandButton value="Gravar" action="#{livroBean.gravar}" >
    <f:ajax execute="@form" render="@form :tabelaLivros"/>
</h:commandButton>

Revisando as funcionalidades da aplicação

Vamos mostrar uma vez todas as funcionalidades abrindo novamente o navegador. Ao apertar o botão Gravar será enviado um request AJAX. 
Como há dados inválidos, as mensagens de validação são mostradas. Depois preenchemos o campo Titulo, que envia outro request AJAX após 
perder o focus. Ao preencher os outros dados e gravar o livro será testada a existência do Autor. Na escolha do Autor também usamos
AJAX para enviá-lo e atualizar a sua tabela. No final podemos cadastrar o Livro, que causa a atualização do formulário e da tabela de livros. 
Repare que em nenhum momento a página foi atualizada totalmente, pois utilizamos AJAX.








Navegação entre Páginas e o Ciclo de vida - JSF.

Navegação, links: {
	https://stackoverflow.com/questions/11242240/semantics-of-faces-redirect-true-in-commandlink-action-and-why-not-use
	https://stackoverflow.com/questions/2990399/faces-redirect-true-in-jsf
}

Necessária um configuração no arquivo faces-config.xml :

	<lifecycle>
    	<phase-listener>br.com.caelum.livraria.utils.LogPhaseListener</phase-listener>
    </lifecycle>
    
Também é interessante desabilitar o log do Hibernate.

Ciclo de vida - Explicado:

Criação da view e renderização: RESTORE_VIEW e RENDER_RESPONSE

Agora o console do Eclipse só mostra a saída do nosso PhaseListener. Podemos ver que duas fases foram acionadas, 
a primeira chamada RESTORE_VIEW e outra, a sexta fase chamada RENDER_RESPONSE. Repare que o PhaseListener automaticamente 
numerou as fases.
Ao receber uma requisição HTTP do tipo GET o controlador iniciou o ciclo da vida da tela. Isso significa que ele leu o 
arquivo xhtml e instanciou todos os componentes. Como isso foi disparado pela requisição inicial está claro que não 
há nada a fazer além de renderizar a resposta.



Analisandos as fases: APPLY_REQUEST_VALUES e PROCESS_VALIDATION

No Eclipse novamente limparemos a console e mais uma vez no navegador usaremos o formulário para executar uma validação. 
Lembrando que o campo do título automaticamente envia uma requisição AJAX ao perder foco e consequentemente é executada 
a validação no lado do servidor.
Olhando o console no Eclipse podemos ver que dessa vez foram executadas 4 fases. Temos como segunda fase o APPLY_REQUEST_VALUES, 
e como terceira fase PROCESS_VALIDATION.

Vamos analisar também esse caso. Como sempre o controlador recebeu a requisição mas agora ela é do tipo POST. 
Isso significa que o controlador apenas recupera a árvore (por isso se chama RESTORE_VIEW). Após a recuperação 
da tela os componentes recebem o valor digitado pelo usuário que vem da requisição (dai vem o nome APPLY_REQUEST_VALUE). 
Nesse caso submetemos apenas o valor do titular, mas em branco. Em outras palavras, o componente do titular 
recebe um String vazio.

Na terceira fase acontece a conversão, se for preciso, e a validação. O titulo não precisa ser convertido pois o 
titulo é do tipo String, mas associamos uma validação com o componente. É justamente essa validação que falha. 
Em geral, se há um problema de conversão ou validação, o controlador pula automaticamente as fases quatro e cinco 
e pede renderizar o HTML com as mensagens de erro.



Todas as fases do ciclo

Agora testaremos o que acontece quando escolhemos um autor no combobox. Vamos apertar o botão e verificar a console de novo. 
Repare que agora foram executadas todas as seis fases. Na primeira fase (RESTORE_VIEW) foi recuperada a árvore de componentes 
da sessão, na segunda (APPLY_REQUEST_VALUES) os componentes receberam os parâmetros da requisição e na terceira (PROCESS_VALIDATION) 
todos os dados foram convertidos e validados.

Como nenhum erro ocorreu na terceira fase o controlador continua com a próxima que se chama UPDATE_VALUES. 
Aqui o modelo será atualizado com os valores convertidos na fase anterior. Neste caso, LivroBean recebe apenas ID do autor 
já que só enviamos essa parâmetro pelo AJAX. Em geral, nesta fase, tudo que definimos com a expression language nos 
componentes de inputs é atualizado no modelo.

Agora que o modelo já foi atualizado, nosso LivroBean já pode executar o comando definido via expression languague. 
Este comando é um método no próprio LivroBean e opera sobre os dados convertidos. Esta fase de chamada de métodos 
no ManagedBean é chamada de INVOKE_APPLICATION.

Por fim, o JSF devolve uma resposta para o usuário, o que é feito na última fase, RENDER_RESPONSE.



Uso do immediate="true" para pular fases e fazer o redirecionamento 

Uso do ?faces-redirect=true para fazer o redirecionamento e não forward, isso porque será feito pelo navegador e não pelo servidor.
    





Templates reutilizáveis com Facelets
 
Imagens, css, javascript devem estar numa pasta chamada resources a partir do JSF 2 dentro de WebContent

	WebContent/resources

Voltando a tag <h:grahicImage />, definiremos dois atributos. O primeiro é o library. Nele, preencheremos com o valor img, 
a pasta que contém nosso logo dentro de resources. O segundo é o name. Nele definimos o nome do arquivo, em nosso caso, logo.png. 
Vamos iniciar o servidor e verificar o resultado. O logo é exibido como esperado.

	<h:graphicImage library="img" name="logo.png"  />


